package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"time"

	"github.com/nais/console-backend/internal/database/gensql"
	"github.com/nais/console-backend/internal/graph/model"
)

// Sum is the resolver for the sum field.
func (r *costResolver) Sum(ctx context.Context, obj *model.Cost) (float64, error) {
	sum := 0.0
	for _, series := range obj.Series {
		for _, cost := range series.Data {
			sum += cost.Cost
		}
	}
	return sum, nil
}

// Sum is the resolver for the sum field.
func (r *costSeriesResolver) Sum(ctx context.Context, obj *model.CostSeries) (float64, error) {
	sum := 0.0
	for _, cost := range obj.Data {
		sum += cost.Cost
	}
	return sum, nil
}

// Cost is the resolver for the cost field.
func (r *queryResolver) Cost(ctx context.Context, filter model.CostFilter) (*model.Cost, error) {
	if filter.From == nil {
		start := model.NewDate(time.Now().Add(-7 * time.Hour * 24))
		filter.From = &start
	}

	today := model.NewDate(time.Now())
	if filter.To == nil {
		filter.To = &today
	}

	if *filter.From > *filter.To {
		return nil, fmt.Errorf("from date cannot be after to date")
	} else if *filter.To > today {
		return nil, fmt.Errorf("to date cannot be in the future")
	}

	if filter.App != "" && filter.Env != "" && filter.Team != "" && filter.From != nil && filter.To != nil {
		rows, err := r.Queries.CostForApp(ctx, gensql.CostForAppParams{
			App:      &filter.App,
			Team:     &filter.Team,
			Env:      &filter.Env,
			FromDate: filter.From.PgDate(),
			ToDate:   filter.To.PgDate(),
		})
		if err != nil {
			return nil, fmt.Errorf("cost query: %w", err)
		}

		costs := DailyCostsFromDatabaseRows(*filter.From, *filter.To, rows)
		series := make([]*model.CostSeries, 0)
		for costType, data := range costs {
			series = append(series, &model.CostSeries{
				CostType: costType,
				Data:     data,
				App:      filter.App,
				Team:     filter.Team,
				Env:      filter.Env,
			})
		}

		return &model.Cost{
			From:   *filter.From,
			To:     *filter.To,
			Series: series,
		}, nil
	} /*else if filter.Env != "" && filter.Team != "" && filter.StartDate != nil && filter.EndDate != nil {
		params := gensql.CostForAppParams{}
		params.Team = &filter.Team
		params.Env = &filter.Env
		params.FromDate.Time = filter.StartDate.UTC()
		params.FromDate.Valid = true
		params.ToDate.Time = filter.EndDate.UTC()
		params.ToDate.Valid = true
		rows, err := r.Queries.CostForApp(ctx, params)
		if err != nil {
			return nil, fmt.Errorf("cost query: %w", err)
		}

		cost := &model.Cost{}
		cost.Series = make([]*model.CostSeries, 0)

		for _, row := range rows {
			cost.Series = append(cost.Series, &model.CostSeries{
				CostType: row.CostType,
				Data:     []float64{float64(row.Cost)},
				App:      *row.App,
				Team:     *row.Team,
				Env:      *row.Env,
			})

		}
	}
	*/
	return nil, fmt.Errorf("not implemented")
}

// Cost returns CostResolver implementation.
func (r *Resolver) Cost() CostResolver { return &costResolver{r} }

// CostSeries returns CostSeriesResolver implementation.
func (r *Resolver) CostSeries() CostSeriesResolver { return &costSeriesResolver{r} }

type (
	costResolver       struct{ *Resolver }
	costSeriesResolver struct{ *Resolver }
)
