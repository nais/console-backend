// Code generated by mockery. DO NOT EDIT.

package gensql

import (
	context "context"

	pgtype "github.com/jackc/pgx/v5/pgtype"
	mock "github.com/stretchr/testify/mock"
)

// MockQuerier is an autogenerated mock type for the Querier type
type MockQuerier struct {
	mock.Mock
}

type MockQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockQuerier) EXPECT() *MockQuerier_Expecter {
	return &MockQuerier_Expecter{mock: &_m.Mock}
}

// CostUpsert provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) CostUpsert(ctx context.Context, arg []CostUpsertParams) *CostUpsertBatchResults {
	ret := _m.Called(ctx, arg)

	var r0 *CostUpsertBatchResults
	if rf, ok := ret.Get(0).(func(context.Context, []CostUpsertParams) *CostUpsertBatchResults); ok {
		r0 = rf(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*CostUpsertBatchResults)
		}
	}

	return r0
}

// MockQuerier_CostUpsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CostUpsert'
type MockQuerier_CostUpsert_Call struct {
	*mock.Call
}

// CostUpsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg []CostUpsertParams
func (_e *MockQuerier_Expecter) CostUpsert(ctx interface{}, arg interface{}) *MockQuerier_CostUpsert_Call {
	return &MockQuerier_CostUpsert_Call{Call: _e.mock.On("CostUpsert", ctx, arg)}
}

func (_c *MockQuerier_CostUpsert_Call) Run(run func(ctx context.Context, arg []CostUpsertParams)) *MockQuerier_CostUpsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]CostUpsertParams))
	})
	return _c
}

func (_c *MockQuerier_CostUpsert_Call) Return(_a0 *CostUpsertBatchResults) *MockQuerier_CostUpsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_CostUpsert_Call) RunAndReturn(run func(context.Context, []CostUpsertParams) *CostUpsertBatchResults) *MockQuerier_CostUpsert_Call {
	_c.Call.Return(run)
	return _c
}

// DailyCostForApp provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) DailyCostForApp(ctx context.Context, arg DailyCostForAppParams) ([]*Cost, error) {
	ret := _m.Called(ctx, arg)

	var r0 []*Cost
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DailyCostForAppParams) ([]*Cost, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DailyCostForAppParams) []*Cost); ok {
		r0 = rf(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Cost)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DailyCostForAppParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_DailyCostForApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DailyCostForApp'
type MockQuerier_DailyCostForApp_Call struct {
	*mock.Call
}

// DailyCostForApp is a helper method to define mock.On call
//   - ctx context.Context
//   - arg DailyCostForAppParams
func (_e *MockQuerier_Expecter) DailyCostForApp(ctx interface{}, arg interface{}) *MockQuerier_DailyCostForApp_Call {
	return &MockQuerier_DailyCostForApp_Call{Call: _e.mock.On("DailyCostForApp", ctx, arg)}
}

func (_c *MockQuerier_DailyCostForApp_Call) Run(run func(ctx context.Context, arg DailyCostForAppParams)) *MockQuerier_DailyCostForApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DailyCostForAppParams))
	})
	return _c
}

func (_c *MockQuerier_DailyCostForApp_Call) Return(_a0 []*Cost, _a1 error) *MockQuerier_DailyCostForApp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_DailyCostForApp_Call) RunAndReturn(run func(context.Context, DailyCostForAppParams) ([]*Cost, error)) *MockQuerier_DailyCostForApp_Call {
	_c.Call.Return(run)
	return _c
}

// DailyCostForTeam provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) DailyCostForTeam(ctx context.Context, arg DailyCostForTeamParams) ([]*Cost, error) {
	ret := _m.Called(ctx, arg)

	var r0 []*Cost
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DailyCostForTeamParams) ([]*Cost, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DailyCostForTeamParams) []*Cost); ok {
		r0 = rf(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Cost)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DailyCostForTeamParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_DailyCostForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DailyCostForTeam'
type MockQuerier_DailyCostForTeam_Call struct {
	*mock.Call
}

// DailyCostForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - arg DailyCostForTeamParams
func (_e *MockQuerier_Expecter) DailyCostForTeam(ctx interface{}, arg interface{}) *MockQuerier_DailyCostForTeam_Call {
	return &MockQuerier_DailyCostForTeam_Call{Call: _e.mock.On("DailyCostForTeam", ctx, arg)}
}

func (_c *MockQuerier_DailyCostForTeam_Call) Run(run func(ctx context.Context, arg DailyCostForTeamParams)) *MockQuerier_DailyCostForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DailyCostForTeamParams))
	})
	return _c
}

func (_c *MockQuerier_DailyCostForTeam_Call) Return(_a0 []*Cost, _a1 error) *MockQuerier_DailyCostForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_DailyCostForTeam_Call) RunAndReturn(run func(context.Context, DailyCostForTeamParams) ([]*Cost, error)) *MockQuerier_DailyCostForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// DailyEnvCostForTeam provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) DailyEnvCostForTeam(ctx context.Context, arg DailyEnvCostForTeamParams) ([]*DailyEnvCostForTeamRow, error) {
	ret := _m.Called(ctx, arg)

	var r0 []*DailyEnvCostForTeamRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DailyEnvCostForTeamParams) ([]*DailyEnvCostForTeamRow, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DailyEnvCostForTeamParams) []*DailyEnvCostForTeamRow); ok {
		r0 = rf(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*DailyEnvCostForTeamRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DailyEnvCostForTeamParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_DailyEnvCostForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DailyEnvCostForTeam'
type MockQuerier_DailyEnvCostForTeam_Call struct {
	*mock.Call
}

// DailyEnvCostForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - arg DailyEnvCostForTeamParams
func (_e *MockQuerier_Expecter) DailyEnvCostForTeam(ctx interface{}, arg interface{}) *MockQuerier_DailyEnvCostForTeam_Call {
	return &MockQuerier_DailyEnvCostForTeam_Call{Call: _e.mock.On("DailyEnvCostForTeam", ctx, arg)}
}

func (_c *MockQuerier_DailyEnvCostForTeam_Call) Run(run func(ctx context.Context, arg DailyEnvCostForTeamParams)) *MockQuerier_DailyEnvCostForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DailyEnvCostForTeamParams))
	})
	return _c
}

func (_c *MockQuerier_DailyEnvCostForTeam_Call) Return(_a0 []*DailyEnvCostForTeamRow, _a1 error) *MockQuerier_DailyEnvCostForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_DailyEnvCostForTeam_Call) RunAndReturn(run func(context.Context, DailyEnvCostForTeamParams) ([]*DailyEnvCostForTeamRow, error)) *MockQuerier_DailyEnvCostForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// LastCostDate provides a mock function with given fields: ctx
func (_m *MockQuerier) LastCostDate(ctx context.Context) (pgtype.Date, error) {
	ret := _m.Called(ctx)

	var r0 pgtype.Date
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (pgtype.Date, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) pgtype.Date); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(pgtype.Date)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_LastCostDate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LastCostDate'
type MockQuerier_LastCostDate_Call struct {
	*mock.Call
}

// LastCostDate is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQuerier_Expecter) LastCostDate(ctx interface{}) *MockQuerier_LastCostDate_Call {
	return &MockQuerier_LastCostDate_Call{Call: _e.mock.On("LastCostDate", ctx)}
}

func (_c *MockQuerier_LastCostDate_Call) Run(run func(ctx context.Context)) *MockQuerier_LastCostDate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQuerier_LastCostDate_Call) Return(_a0 pgtype.Date, _a1 error) *MockQuerier_LastCostDate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_LastCostDate_Call) RunAndReturn(run func(context.Context) (pgtype.Date, error)) *MockQuerier_LastCostDate_Call {
	_c.Call.Return(run)
	return _c
}

// MaxResourceUtilizationDate provides a mock function with given fields: ctx
func (_m *MockQuerier) MaxResourceUtilizationDate(ctx context.Context) (pgtype.Timestamptz, error) {
	ret := _m.Called(ctx)

	var r0 pgtype.Timestamptz
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (pgtype.Timestamptz, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) pgtype.Timestamptz); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(pgtype.Timestamptz)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_MaxResourceUtilizationDate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxResourceUtilizationDate'
type MockQuerier_MaxResourceUtilizationDate_Call struct {
	*mock.Call
}

// MaxResourceUtilizationDate is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQuerier_Expecter) MaxResourceUtilizationDate(ctx interface{}) *MockQuerier_MaxResourceUtilizationDate_Call {
	return &MockQuerier_MaxResourceUtilizationDate_Call{Call: _e.mock.On("MaxResourceUtilizationDate", ctx)}
}

func (_c *MockQuerier_MaxResourceUtilizationDate_Call) Run(run func(ctx context.Context)) *MockQuerier_MaxResourceUtilizationDate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQuerier_MaxResourceUtilizationDate_Call) Return(_a0 pgtype.Timestamptz, _a1 error) *MockQuerier_MaxResourceUtilizationDate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_MaxResourceUtilizationDate_Call) RunAndReturn(run func(context.Context) (pgtype.Timestamptz, error)) *MockQuerier_MaxResourceUtilizationDate_Call {
	_c.Call.Return(run)
	return _c
}

// MonthlyCostForApp provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) MonthlyCostForApp(ctx context.Context, arg MonthlyCostForAppParams) ([]*MonthlyCostForAppRow, error) {
	ret := _m.Called(ctx, arg)

	var r0 []*MonthlyCostForAppRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, MonthlyCostForAppParams) ([]*MonthlyCostForAppRow, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, MonthlyCostForAppParams) []*MonthlyCostForAppRow); ok {
		r0 = rf(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*MonthlyCostForAppRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, MonthlyCostForAppParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_MonthlyCostForApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MonthlyCostForApp'
type MockQuerier_MonthlyCostForApp_Call struct {
	*mock.Call
}

// MonthlyCostForApp is a helper method to define mock.On call
//   - ctx context.Context
//   - arg MonthlyCostForAppParams
func (_e *MockQuerier_Expecter) MonthlyCostForApp(ctx interface{}, arg interface{}) *MockQuerier_MonthlyCostForApp_Call {
	return &MockQuerier_MonthlyCostForApp_Call{Call: _e.mock.On("MonthlyCostForApp", ctx, arg)}
}

func (_c *MockQuerier_MonthlyCostForApp_Call) Run(run func(ctx context.Context, arg MonthlyCostForAppParams)) *MockQuerier_MonthlyCostForApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(MonthlyCostForAppParams))
	})
	return _c
}

func (_c *MockQuerier_MonthlyCostForApp_Call) Return(_a0 []*MonthlyCostForAppRow, _a1 error) *MockQuerier_MonthlyCostForApp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_MonthlyCostForApp_Call) RunAndReturn(run func(context.Context, MonthlyCostForAppParams) ([]*MonthlyCostForAppRow, error)) *MockQuerier_MonthlyCostForApp_Call {
	_c.Call.Return(run)
	return _c
}

// MonthlyCostForTeam provides a mock function with given fields: ctx, team
func (_m *MockQuerier) MonthlyCostForTeam(ctx context.Context, team *string) ([]*MonthlyCostForTeamRow, error) {
	ret := _m.Called(ctx, team)

	var r0 []*MonthlyCostForTeamRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *string) ([]*MonthlyCostForTeamRow, error)); ok {
		return rf(ctx, team)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *string) []*MonthlyCostForTeamRow); ok {
		r0 = rf(ctx, team)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*MonthlyCostForTeamRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *string) error); ok {
		r1 = rf(ctx, team)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_MonthlyCostForTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MonthlyCostForTeam'
type MockQuerier_MonthlyCostForTeam_Call struct {
	*mock.Call
}

// MonthlyCostForTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - team *string
func (_e *MockQuerier_Expecter) MonthlyCostForTeam(ctx interface{}, team interface{}) *MockQuerier_MonthlyCostForTeam_Call {
	return &MockQuerier_MonthlyCostForTeam_Call{Call: _e.mock.On("MonthlyCostForTeam", ctx, team)}
}

func (_c *MockQuerier_MonthlyCostForTeam_Call) Run(run func(ctx context.Context, team *string)) *MockQuerier_MonthlyCostForTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*string))
	})
	return _c
}

func (_c *MockQuerier_MonthlyCostForTeam_Call) Return(_a0 []*MonthlyCostForTeamRow, _a1 error) *MockQuerier_MonthlyCostForTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_MonthlyCostForTeam_Call) RunAndReturn(run func(context.Context, *string) ([]*MonthlyCostForTeamRow, error)) *MockQuerier_MonthlyCostForTeam_Call {
	_c.Call.Return(run)
	return _c
}

// ResourceUtilizationUpsert provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) ResourceUtilizationUpsert(ctx context.Context, arg []ResourceUtilizationUpsertParams) *ResourceUtilizationUpsertBatchResults {
	ret := _m.Called(ctx, arg)

	var r0 *ResourceUtilizationUpsertBatchResults
	if rf, ok := ret.Get(0).(func(context.Context, []ResourceUtilizationUpsertParams) *ResourceUtilizationUpsertBatchResults); ok {
		r0 = rf(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ResourceUtilizationUpsertBatchResults)
		}
	}

	return r0
}

// MockQuerier_ResourceUtilizationUpsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResourceUtilizationUpsert'
type MockQuerier_ResourceUtilizationUpsert_Call struct {
	*mock.Call
}

// ResourceUtilizationUpsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg []ResourceUtilizationUpsertParams
func (_e *MockQuerier_Expecter) ResourceUtilizationUpsert(ctx interface{}, arg interface{}) *MockQuerier_ResourceUtilizationUpsert_Call {
	return &MockQuerier_ResourceUtilizationUpsert_Call{Call: _e.mock.On("ResourceUtilizationUpsert", ctx, arg)}
}

func (_c *MockQuerier_ResourceUtilizationUpsert_Call) Run(run func(ctx context.Context, arg []ResourceUtilizationUpsertParams)) *MockQuerier_ResourceUtilizationUpsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]ResourceUtilizationUpsertParams))
	})
	return _c
}

func (_c *MockQuerier_ResourceUtilizationUpsert_Call) Return(_a0 *ResourceUtilizationUpsertBatchResults) *MockQuerier_ResourceUtilizationUpsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_ResourceUtilizationUpsert_Call) RunAndReturn(run func(context.Context, []ResourceUtilizationUpsertParams) *ResourceUtilizationUpsertBatchResults) *MockQuerier_ResourceUtilizationUpsert_Call {
	_c.Call.Return(run)
	return _c
}

// TruncateCostTable provides a mock function with given fields: ctx
func (_m *MockQuerier) TruncateCostTable(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_TruncateCostTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TruncateCostTable'
type MockQuerier_TruncateCostTable_Call struct {
	*mock.Call
}

// TruncateCostTable is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQuerier_Expecter) TruncateCostTable(ctx interface{}) *MockQuerier_TruncateCostTable_Call {
	return &MockQuerier_TruncateCostTable_Call{Call: _e.mock.On("TruncateCostTable", ctx)}
}

func (_c *MockQuerier_TruncateCostTable_Call) Run(run func(ctx context.Context)) *MockQuerier_TruncateCostTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQuerier_TruncateCostTable_Call) Return(_a0 error) *MockQuerier_TruncateCostTable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_TruncateCostTable_Call) RunAndReturn(run func(context.Context) error) *MockQuerier_TruncateCostTable_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockQuerier creates a new instance of MockQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockQuerier(t interface {
	mock.TestingT
	Cleanup(func())
},
) *MockQuerier {
	mock := &MockQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
